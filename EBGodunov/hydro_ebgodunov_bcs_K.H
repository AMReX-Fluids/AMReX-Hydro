/**
 * \file hydro_ebgodunov_K.H
 *
 * \addtogroup EBGodunov
 *  @{
 */

#ifndef HYDRO_EBGODUNOV_K_H
#define HYDRO_EBGODUNOV_K_H

#include <AMReX_Gpu.H>
#include <AMReX_BCRec.H>
#include <AMReX_BC_TYPES.H>
#include <AMReX_Array.H>
#include <iomanip>
#include <hydro_constants.H>

/* This header file contains the inlined __host__ __device__ functions required
   for setting BCs for computing the advective velocity and transverse terms in
   3D EBGodunov ExtrapVel.
*/

namespace EBGodunovBC {

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
void SetXBCs (const int i, const int j, const int k, const int n,
              const amrex::Array4<const amrex::Real> &s,
              amrex::Real &lo,
              amrex::Real &hi,
              const int bclo, const int bchi,
              const int domlo, const int domhi,
              const bool is_velocity,
              const amrex::Array4<const int> const& bc_arr = {})
{
    using namespace amrex;


    // Low X
    if (i <= domlo)
    {
        int bc = bc_arr ? bc_arr(domlo-1, j, k, n) : bclo;

        if (bc==BCType::ext_dir)
        {
            lo = s(domlo-1,j,k,n);
            // For turbulent inflow, there are times when the inflow face
            // may have a predicted outflowing velocity. Here, we preserve
            // the normal component of the Dirichlet BC, but allow the
            // tangential components to transport values from the interior.
            if( n == XVEL && is_velocity ) hi=lo;
        }
        else if (bc == BCType::foextrap || bc == BCType::hoextrap)
        {
            lo = hi;
        } else if (bc == BCType::reflect_even)
        {
            lo = hi;

            if ( i<domlo)
                Abort("EBGodunovBC::SetXBCs not yet fully implemented for reflect_even BC. See comments in EBGodunovBC::SetXBCs.");
            //
            // Note that this is only relevant for 3D, as only 3D ever needs to
            // set the BC beyond the domain face.
            // This is potentially tricky because the code re-uses some of the
            // space holding the holding the states passed in here; it puts the
            // upwinded intermediate edge state in Imx (which supplies hi)
            // With GPU, I think it's undertermined which Imx(i+..) you'll get here,
            // could be from PLM, could be the upwinded edgestate.
            // Question is whether every thread in the stream has to finish a kernel
            // before the next kernel is launched.
            // lo = hi_arr(2*domlo-i  ,j,k,n);
            // hi = lo_arr(2*domlo-i-1,j,k,n);
        }
        else if (bc == BCType::reflect_odd)
        {
            if ( i==domlo ) {
                hi = 0.;
                lo = 0.;
            } else {
                Abort("EBGodunovBC::SetXBCs not yet fully implemented for reflect_odd BC. See comments in EBGodunovBC::SetXBCs.");
            //     lo = -hi_arr(2*domlo-i  ,j,k,n);
            //     hi = -lo_arr(2*domlo-i-1,j,k,n);
            }
        }
    }
    // High X
    else if (i > domhi)
    {
        int bc = bc_arr ? bc_arr(domhi+1, j, k, n) : bchi;

        if (bc==BCType::ext_dir)
        {
            hi = s(domhi+1,j,k,n) ;
            if( n ==XVEL && is_velocity ) lo=hi;
        }
        else if (bc == BCType::foextrap || bc == BCType::hoextrap )
        {
            hi = lo;
        }
        else if (bc == BCType::reflect_even)
        {
            hi = lo;

            if ( i>domhi+1 )
                Abort("EBGodunovBC::SetXBCs not yet fully implemented for reflect_even BC. See comments in EBGodunovBC::SetXBCs.");
            // hi = lo_arr(2*(domhi+1)-i-1,j,k,n);
            // lo = hi_arr(2*(domhi+1)-i  ,j,k,n);
        }
        else if (bc == BCType::reflect_odd)
        {
            if ( i==domhi+1 ) {
                hi = 0.;
                lo = 0.;
            } else {
                Abort("EBGodunovBC::SetXBCs not yet fully implemented for reflect_odd BC. See comments in EBGodunovBC::SetXBCs.");
            //     hi = -lo_arr(2*(domhi+1)-i-1,j,k,n);
            //     lo = -hi_arr(2*(domhi+1)-i  ,j,k,n);
            }
        }
    }
    else
        return;
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
void SetYBCs (const int i, const int j, const int k, const int n,
              const amrex::Array4<const amrex::Real> &s,
              amrex::Real &lo,
              amrex::Real &hi,
              const int bclo, const int bchi,
              const int domlo, const int domhi,
              const bool is_velocity,
              const amrex::Array4<const int> const& bc_arr = {})
{
    using namespace amrex;


    // Low Y
    if (j <= domlo)
    {
        int bc = bc_arr ? bc_arr(i, domlo-1, k, n) : bclo;

        if (bc==BCType::ext_dir)
        {
            lo = s(i,domlo-1,k,n);
            if ( n == YVEL && is_velocity ) hi = lo;
        }
        else if (bc == BCType::foextrap || bc == BCType::hoextrap)
        {
            lo = hi;
        }
        else if (bc == BCType::reflect_even)
        {
            lo = hi;

            if  ( j<domlo )
                Abort("EBGodunovBC::SetYBCs not yet fully implemented for reflect_even BC. See comments in EBGodunovBC::SetXBCs.");
            // lo = hi_arr(i,2*domlo-j  ,k,n);
            // hi = lo_arr(i,2*domlo-j-1,k,n);
        }
        else if(bc == BCType::reflect_odd)
        {
            if ( j==domlo ) {
                hi = 0.;
                lo = 0.;
            } else {
                Abort("EBGodunovBC::SetYBCs not yet fully implemented for reflect_odd BC. See comments in EBGodunovBC::SetXBCs.");
            //     lo = -hi_arr(i,2*domlo-j  ,k,n);
            //     hi = -lo_arr(i,2*domlo-j-1,k,n);
            }
        }
    }
    // High Y
    else if (j > domhi)
    {
        int bc = bc_arr ? bc_arr(i, domhi+1, k, n) : bchi;

        if (bc==BCType::ext_dir)
        {
            hi = s(i,domhi+1,k,n);
            if( n == YVEL && is_velocity ) lo = hi ;
        }
        else if (bc == BCType::foextrap || bc == BCType::hoextrap)
        {
            hi = lo;
        }
        else if (bc == BCType::reflect_even)
        {
            hi = lo;

            if ( j>domhi+1)
                Abort("EBGodunovBC::SetYBCs not yet fully implemented for reflect_even BC. See comments in EBGodunovBC::SetXBCs.");
            // hi = lo_arr(i,2*(domhi+1)-j-1,k,n);
            // lo = hi_arr(i,2*(domhi+1)-j  ,k,n);
        }
        else if (bc == BCType::reflect_odd)
        {
            if ( j==domhi+1 ) {
                hi = 0.;
                lo = 0.;
            } else {
                Abort("EBGodunovBC::SetYBCs not yet fully implemented for reflect_odd BC. See comments in EBGodunovBC::SetXBCs.");
            //     hi = -lo_arr(i,2*(domhi+1)-j-1,k,n);
            //     lo = -hi_arr(i,2*(domhi+1)-j  ,k,n);
            }
        }
    }
    else
        return;
}

#if (AMREX_SPACEDIM==3)
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
void SetZBCs(const int i, const int j, const int k, const int n,
             const amrex::Array4<const amrex::Real> &s,
             amrex::Real &lo,
             amrex::Real &hi,
             const int bclo, const int bchi,
             const int domlo, const int domhi,
             const bool is_velocity,
              const amrex::Array4<const int> const& bc_arr = {})
{
    using namespace amrex;


    // Low Z
    if (k <= domlo)
    {
        int bc = bc_arr ? bc_arr(i, j, domlo-1, n) : bclo;

        if (bc==BCType::ext_dir)
        {
            lo =s(i,j,domlo-1,n);
            if ( n == ZVEL && is_velocity ) hi = lo;
        }
        else if (bc == BCType::foextrap || bc == BCType::hoextrap)
        {
            lo = hi;
        }
        else if (bc == BCType::reflect_even)
        {
            Abort("EBGodunovBC::SetZBCs not yet implemented for reflect_even BC. See comments in EBGodunovBC::SetXBCs.");
            // lo = hi_arr(i,j,2*domlo-k  ,n);
            // hi = lo_arr(i,j,2*domlo-k-1,n);
        }
        else if(bc == BCType::reflect_odd)
        {
            Abort("EBGodunovBC::SetZBCs not yet implemented for reflect_odd BC. See comments in EBGodunovBC::SetXBCs.");
            // if ( k==domlo ) {
            //     hi = 0.;
            //     lo = 0.;
            // } else {
            //     lo = -hi_arr(i,j,2*domlo-k  ,n);
            //     hi = -lo_arr(i,j,2*domlo-k-1,n);
            // }
        }
    }
    // High Z
    else if (k > domhi)
    {
        int bc = bc_arr ? bc_arr(i, j, domhi+1, n) : bchi;

        if (bc==BCType::ext_dir)
        {
            hi = s(i,j,domhi+1,n);
            if ( n == ZVEL && is_velocity ) lo = hi ;
        }
        else if (bc == BCType::foextrap || bc == BCType::hoextrap)
        {
            hi = lo;
        }
        else if (bc == BCType::reflect_even)
        {
            Abort("EBGodunovBC::SetZBCs not yet implemented for reflect_even BC. See comments in EBGodunovBC::SetXBCs.");
            // hi = lo_arr(i,j,2*(domhi+1)-k-1,n);
            // lo = hi_arr(i,j,2*(domhi+1)-k  ,n);
        }
        else if (bc == BCType::reflect_odd)
        {
            Abort("EBGodunovBC::SetZBCs not yet implemented for reflect_odd BC. See comments in EBGodunovBC::SetXBCs.");
            // if ( k==domhi+1 ) {
            //     hi = 0.;
            //     lo = 0.;
            // } else {
            //     hi = -lo_arr(i,j,2*(domhi+1)-k-1,n);
            //     lo = -hi_arr(i,j,2*(domhi+1)-k  ,n);
            // }
        }
    }
    else
        return;
}
#endif
}
#endif
/** @} */
